"""
Adobe Creative Cloud Export Module

This module provides enhanced video export capabilities specifically designed
for Adobe Creative Cloud compatibility, including proper codecs, metadata,
and sidecar files for seamless integration.
"""

import os
import json
import subprocess
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import cv2
import numpy as np

logger = logging.getLogger(__name__)


class AdobeExporter:
    """
    Enhanced video export for Adobe Creative Cloud compatibility.
    
    Features:
    - H.264 codec with Adobe-optimized settings
    - Embedded metadata for Premiere Pro
    - Sidecar files for analysis data
    - Multiple export formats (ProRes, DNxHD, etc.)
    - Automated FFmpeg pipeline
    """
    
    def __init__(self, ffmpeg_path: str = "ffmpeg"):
        self.ffmpeg_path = ffmpeg_path
        self.adobe_codecs = {
            'h264': {
                'codec': 'libx264',
                'preset': 'medium',
                'crf': 18,  # High quality
                'profile': 'high',
                'level': '4.1',
                'pix_fmt': 'yuv420p'
            },
            'prores': {
                'codec': 'prores_ks',
                'profile': 'standard',
                'pix_fmt': 'yuv422p10le'
            },
            'dnxhd': {
                'codec': 'dnxhd',
                'profile': 'dnxhd_1080p_36',
                'pix_fmt': 'yuv422p'
            }
        }
    
    def export_analysis_video(self, 
                            input_video: str,
                            output_path: str,
                            analysis_data: Dict,
                            export_format: str = 'h264',
                            include_overlays: bool = True,
                            metadata: Optional[Dict] = None) -> bool:
        """
        Export analysis video in Adobe-compatible format.
        
        Args:
            input_video: Path to input video file
            output_path: Output video path
            analysis_data: Analysis results dictionary
            export_format: 'h264', 'prores', or 'dnxhd'
            include_overlays: Whether to include OpenCV overlays
            metadata: Additional metadata to embed
        
        Returns:
            bool: Success status
        """
        try:
            # Create output directory
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            
            # Generate sidecar metadata
            sidecar_path = self._create_sidecar_metadata(
                output_path, analysis_data, metadata
            )
            
            if export_format == 'h264':
                return self._export_h264(input_video, output_path, analysis_data, include_overlays)
            elif export_format == 'prores':
                return self._export_prores(input_video, output_path, analysis_data, include_overlays)
            elif export_format == 'dnxhd':
                return self._export_dnxhd(input_video, output_path, analysis_data, include_overlays)
            else:
                logger.error(f"Unsupported export format: {export_format}")
                return False
                
        except Exception as e:
            logger.error(f"Export failed: {e}")
            return False
    
    def _export_h264(self, input_video: str, output_path: str, 
                    analysis_data: Dict, include_overlays: bool) -> bool:
        """Export using H.264 codec optimized for Adobe Premiere Pro."""
        
        codec_settings = self.adobe_codecs['h264']
        
        # Build FFmpeg command
        cmd = [
            self.ffmpeg_path,
            '-i', input_video,
            '-c:v', codec_settings['codec'],
            '-preset', codec_settings['preset'],
            '-crf', str(codec_settings['crf']),
            '-profile:v', codec_settings['profile'],
            '-level', codec_settings['level'],
            '-pix_fmt', codec_settings['pix_fmt'],
            '-c:a', 'aac',  # Audio codec
            '-b:a', '128k',  # Audio bitrate
        ]
        
        # Add metadata
        cmd.extend([
            '-metadata', f'title=Pedestrian Analysis - {Path(input_video).stem}',
            '-metadata', f'description=GoPro pedestrian counting analysis',
            '-metadata', f'comment=Generated by CV_MM Analysis System',
            '-metadata', f'creation_time={datetime.now().isoformat()}',
        ])
        
        # Add analysis-specific metadata
        if 'line_crossing_counts' in analysis_data:
            total_crossings = sum(
                sum(dirs.values()) for dirs in analysis_data['line_crossing_counts'].values()
            )
            cmd.extend([
                '-metadata', f'total_pedestrians={total_crossings}',
            ])
        
        if 'avg_density' in analysis_data:
            cmd.extend([
                '-metadata', f'avg_density={analysis_data["avg_density"]:.2f}',
            ])
        
        cmd.append(output_path)
        cmd.append('-y')  # Overwrite output
        
        logger.info(f"Exporting H.264 video: {output_path}")
        logger.debug(f"FFmpeg command: {' '.join(cmd)}")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            logger.info(f"Successfully exported: {output_path}")
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"FFmpeg export failed: {e}")
            logger.error(f"stderr: {e.stderr}")
            return False
    
    def _export_prores(self, input_video: str, output_path: str,
                      analysis_data: Dict, include_overlays: bool) -> bool:
        """Export using Apple ProRes codec for professional editing."""
        
        codec_settings = self.adobe_codecs['prores']
        
        cmd = [
            self.ffmpeg_path,
            '-i', input_video,
            '-c:v', codec_settings['codec'],
            '-profile:v', codec_settings['profile'],
            '-pix_fmt', codec_settings['pix_fmt'],
            '-c:a', 'pcm_s24le',  # Uncompressed audio for ProRes
        ]
        
        # Add metadata
        cmd.extend([
            '-metadata', f'title=Pedestrian Analysis - {Path(input_video).stem}',
            '-metadata', f'description=Professional analysis export',
        ])
        
        cmd.append(output_path)
        cmd.append('-y')
        
        logger.info(f"Exporting ProRes video: {output_path}")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            logger.info(f"Successfully exported ProRes: {output_path}")
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"ProRes export failed: {e}")
            return False
    
    def _export_dnxhd(self, input_video: str, output_path: str,
                     analysis_data: Dict, include_overlays: bool) -> bool:
        """Export using Avid DNxHD codec."""
        
        codec_settings = self.adobe_codecs['dnxhd']
        
        cmd = [
            self.ffmpeg_path,
            '-i', input_video,
            '-c:v', codec_settings['codec'],
            '-profile:v', codec_settings['profile'],
            '-pix_fmt', codec_settings['pix_fmt'],
            '-c:a', 'pcm_s16le',
        ]
        
        cmd.extend([
            '-metadata', f'title=Pedestrian Analysis - {Path(input_video).stem}',
        ])
        
        cmd.append(output_path)
        cmd.append('-y')
        
        logger.info(f"Exporting DNxHD video: {output_path}")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            logger.info(f"Successfully exported DNxHD: {output_path}")
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"DNxHD export failed: {e}")
            return False
    
    def _create_sidecar_metadata(self, output_path: str, analysis_data: Dict,
                               additional_metadata: Optional[Dict] = None) -> str:
        """Create sidecar metadata file for Adobe integration."""
        
        # Generate sidecar file path
        base_path = Path(output_path).with_suffix('')
        sidecar_path = f"{base_path}_metadata.json"
        
        # Prepare metadata
        metadata = {
            'video_info': {
                'source_file': analysis_data.get('video_file', {}).get('path', ''),
                'analysis_date': datetime.now().isoformat(),
                'export_format': 'adobe_compatible',
                'codec': 'h264',
                'resolution': analysis_data.get('video_file', {}).get('resolution', ''),
                'fps': analysis_data.get('video_file', {}).get('fps', 30),
                'duration': analysis_data.get('video_file', {}).get('duration', 0)
            },
            'analysis_results': {
                'total_detections': analysis_data.get('total_detections', 0),
                'total_ingress': analysis_data.get('total_ingress', 0),
                'total_egress': analysis_data.get('total_egress', 0),
                'avg_density': analysis_data.get('avg_density', 0),
                'peak_density': analysis_data.get('peak_density', 0),
                'avg_los': analysis_data.get('avg_los', ''),
                'peak_los': analysis_data.get('peak_los', '')
            },
            'line_crossings': analysis_data.get('line_crossing_counts', {}),
            'net_flows': analysis_data.get('net_flows', {}),
            'frame_results': analysis_data.get('frame_results', []),
            'adobe_integration': {
                'premiere_pro_compatible': True,
                'after_effects_compatible': True,
                'metadata_embedded': True,
                'sidecar_files': True,
                'recommended_import_settings': {
                    'interpret_footage': 'match_source',
                    'frame_rate': 'match_source',
                    'pixel_aspect_ratio': 'square_pixels'
                }
            }
        }
        
        # Add additional metadata if provided
        if additional_metadata:
            metadata.update(additional_metadata)
        
        # Write sidecar file
        with open(sidecar_path, 'w') as f:
            json.dump(metadata, f, indent=2)
        
        logger.info(f"Created sidecar metadata: {sidecar_path}")
        return sidecar_path
    
    def create_adobe_project_files(self, video_path: str, analysis_data: Dict,
                                 output_dir: str) -> Dict[str, str]:
        """
        Create Adobe project files for seamless integration.
        
        Returns:
            Dict with paths to created files
        """
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        base_name = Path(video_path).stem
        
        created_files = {}
        
        # 1. Create Premiere Pro project file (XML)
        premiere_xml = self._create_premiere_xml(video_path, analysis_data, output_path)
        created_files['premiere_xml'] = premiere_xml
        
        # 2. Create After Effects project file (JSON)
        ae_json = self._create_after_effects_json(video_path, analysis_data, output_path)
        created_files['after_effects_json'] = ae_json
        
        # 3. Create marker file for timeline markers
        markers_file = self._create_timeline_markers(video_path, analysis_data, output_path)
        created_files['timeline_markers'] = markers_file
        
        # 4. Create composition settings
        comp_settings = self._create_composition_settings(video_path, analysis_data, output_path)
        created_files['composition_settings'] = comp_settings
        
        return created_files
    
    def _create_premiere_xml(self, video_path: str, analysis_data: Dict, output_path: Path) -> str:
        """Create Premiere Pro XML project file."""
        
        xml_path = output_path / f"{Path(video_path).stem}_premiere.xml"
        
        # Basic Premiere Pro XML structure
        xml_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<PremiereData Version="5.0">
    <Project ObjectID="1" ClassID="62 16 0 0 4 0 0 0 0 0 0 0 0 0 0 0" Version="5">
        <Name>Pedestrian Analysis - {Path(video_path).stem}</Name>
        <Children>
            <ProjectItem ObjectID="2" ClassID="62 16 0 0 4 0 0 0 0 0 0 0 0 0 0 0" Version="5">
                <Name>{Path(video_path).name}</Name>
                <ProjectItemType>Movie</ProjectItemType>
                <MediaPath>{video_path}</MediaPath>
                <MediaType>Movie</MediaType>
                <VideoInfo>
                    <FrameRate>30.00</FrameRate>
                    <FrameSize>
                        <Width>1920</Width>
                        <Height>1080</Height>
                    </FrameSize>
                </VideoInfo>
            </ProjectItem>
        </Children>
        <Sequences>
            <Sequence ObjectID="3" ClassID="62 16 0 0 4 0 0 0 0 0 0 0 0 0 0 0" Version="5">
                <Name>Pedestrian Analysis Sequence</Name>
                <VideoTracks>
                    <VideoTrack ObjectID="4" ClassID="62 16 0 0 4 0 0 0 0 0 0 0 0 0 0 0" Version="5">
                        <Name>V1</Name>
                        <Clips>
                            <Clip ObjectID="5" ClassID="62 16 0 0 4 0 0 0 0 0 0 0 0 0 0 0" Version="5">
                                <Name>{Path(video_path).name}</Name>
                                <Start>0</Start>
                                <End>{analysis_data.get('video_file', {}).get('total_frames', 0)}</End>
                                <ProjectItemRef ObjectID="2"/>
                            </Clip>
                        </Clips>
                    </VideoTrack>
                </VideoTracks>
            </Sequence>
        </Sequences>
    </Project>
</PremiereData>"""
        
        with open(xml_path, 'w') as f:
            f.write(xml_content)
        
        logger.info(f"Created Premiere Pro XML: {xml_path}")
        return str(xml_path)
    
    def _create_after_effects_json(self, video_path: str, analysis_data: Dict, output_path: Path) -> str:
        """Create After Effects project JSON file."""
        
        json_path = output_path / f"{Path(video_path).stem}_after_effects.json"
        
        ae_data = {
            'project_name': f"Pedestrian Analysis - {Path(video_path).stem}",
            'compositions': [
                {
                    'name': 'Pedestrian Analysis Comp',
                    'width': 1920,
                    'height': 1080,
                    'frame_rate': 30,
                    'duration': analysis_data.get('video_file', {}).get('duration', 0),
                    'layers': [
                        {
                            'name': 'Analysis Video',
                            'source': video_path,
                            'type': 'footage',
                            'start_time': 0,
                            'duration': analysis_data.get('video_file', {}).get('duration', 0)
                        },
                        {
                            'name': 'Data Overlay',
                            'type': 'text',
                            'source': 'analysis_data',
                            'properties': {
                                'font_size': 24,
                                'color': [1, 1, 1],
                                'position': [100, 100]
                            }
                        }
                    ]
                }
            ],
            'analysis_data': analysis_data,
            'export_settings': {
                'format': 'H.264',
                'quality': 'high',
                'codec': 'libx264'
            }
        }
        
        with open(json_path, 'w') as f:
            json.dump(ae_data, f, indent=2)
        
        logger.info(f"Created After Effects JSON: {json_path}")
        return str(json_path)
    
    def _create_timeline_markers(self, video_path: str, analysis_data: Dict, output_path: Path) -> str:
        """Create timeline markers file for key events."""
        
        markers_path = output_path / f"{Path(video_path).stem}_markers.csv"
        
        markers = []
        
        # Add markers for peak density periods
        frame_results = analysis_data.get('frame_results', [])
        for i, frame_data in enumerate(frame_results):
            if frame_data.get('density', 0) > analysis_data.get('avg_density', 0) * 1.5:
                markers.append({
                    'time': i * 5,  # 5-second intervals
                    'name': f"High Density - {frame_data.get('density', 0):.2f} peds/mÂ²",
                    'type': 'peak_density',
                    'color': 'red'
                })
        
        # Add markers for LOS changes
        current_los = None
        for i, frame_data in enumerate(frame_results):
            los = frame_data.get('los', '')
            if los != current_los:
                markers.append({
                    'time': i * 5,
                    'name': f"LOS Change to {los}",
                    'type': 'los_change',
                    'color': 'yellow'
                })
                current_los = los
        
        # Write markers CSV
        with open(markers_path, 'w') as f:
            f.write("Time,Name,Type,Color\n")
            for marker in markers:
                f.write(f"{marker['time']},{marker['name']},{marker['type']},{marker['color']}\n")
        
        logger.info(f"Created timeline markers: {markers_path}")
        return str(markers_path)
    
    def _create_composition_settings(self, video_path: str, analysis_data: Dict, output_path: Path) -> str:
        """Create composition settings file."""
        
        settings_path = output_path / f"{Path(video_path).stem}_composition_settings.json"
        
        settings = {
            'composition_name': f"Pedestrian Analysis - {Path(video_path).stem}",
            'settings': {
                'width': 1920,
                'height': 1080,
                'frame_rate': 30,
                'duration': analysis_data.get('video_file', {}).get('duration', 0),
                'pixel_aspect_ratio': 1.0,
                'color_depth': '8 bits per channel',
                'color_space': 'sRGB'
            },
            'recommended_settings': {
                'premiere_pro': {
                    'sequence_preset': 'AVCHD 1080p 30fps',
                    'render_settings': 'High Quality',
                    'export_format': 'H.264'
                },
                'after_effects': {
                    'composition_preset': 'HDTV 1080 29.97',
                    'render_settings': 'Best Settings',
                    'output_module': 'H.264 - Match Source'
                }
            },
            'analysis_overlay_settings': {
                'text_size': 24,
                'text_color': [255, 255, 255],
                'background_opacity': 0.7,
                'position': 'top_left',
                'update_frequency': 'every_frame'
            }
        }
        
        with open(settings_path, 'w') as f:
            json.dump(settings, f, indent=2)
        
        logger.info(f"Created composition settings: {settings_path}")
        return str(settings_path)


def create_adobe_compatible_video(input_video: str, analysis_data: Dict,
                                output_dir: str, export_format: str = 'h264') -> Dict[str, str]:
    """
    Convenience function to create Adobe-compatible exports.
    
    Args:
        input_video: Path to input video
        analysis_data: Analysis results
        output_dir: Output directory
        export_format: Export format ('h264', 'prores', 'dnxhd')
    
    Returns:
        Dict with paths to created files
    """
    exporter = AdobeExporter()
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Generate output video path
    base_name = Path(input_video).stem
    output_video = os.path.join(output_dir, f"{base_name}_adobe_{export_format}.mp4")
    
    # Export video
    success = exporter.export_analysis_video(
        input_video=input_video,
        output_path=output_video,
        analysis_data=analysis_data,
        export_format=export_format
    )
    
    if not success:
        logger.error("Video export failed")
        return {}
    
    # Create Adobe project files
    project_files = exporter.create_adobe_project_files(
        video_path=output_video,
        analysis_data=analysis_data,
        output_dir=output_dir
    )
    
    # Add video path to results
    project_files['exported_video'] = output_video
    
    logger.info(f"Adobe-compatible export completed: {output_dir}")
    return project_files
